#encoding=utf8
'''
state and manager
'''

from log import log
from rule import Rule
import cv2
from skimage.metrics import structural_similarity
import time

class State(): 
    '''
    state
    '''

    def __init__(self): 
        '''
        init
        '''
        self.image              = None
        self.player_hp          = 0
        self.boss_hp            = 0
        self.player_posture     = 0
        self.is_player_hp_down  = False
        self.is_boss_hp_down    = False

        self.is_player_posture_crash    = False

        # if posture down to a reasonable value from former high value.
        self.is_player_posture_down_ok  = False

        # if an attack state / parry after attack state
        self.is_attack                  = False
        self.is_parry_after_attack      = False

        # the number of consecutive parry steps after the attack step.
        # state-10 not included, since it may parry or attack.
        # we will treat it as state-5/6
        self.num_parry_steps_after_attack = 0

        # if the boss attacks the player, and the player's hp drop slightly, < 10 for example.
        self.is_player_hp_down_slightly = False

        # the id derived from the classification model
        # 0/1/2/3/4
        self.class_id           = 0

        self.NORMAL_CLASS_ID    = 0

        # 起跳下击，接突刺
        self.TUCI_CLASS_ID      = 1

        # 擒拿
        self.QINNA_CLASS_ID     = 2

        # 飞渡浮舟
        self.FUZHOU_CLASS_ID    = 3

        # 原地后撤突刺, is very inaccurate
        self.BAD_TUCI_CLASS_ID  = 4

        # real state id, generated by manager
        # 0 1 2 3 4 5 6
        self.state_id           = 0

        # some previous class ids
        self.arr_history_class_id = []

        # state id with more data.
        # it equals to state id actually
        self.final_state_id     = None

        # the key of action space obj
        self.action_space_key   = 'default'


    def get_final_state_id(self): 
        '''
        get final state id 
        '''
        return self.final_state_id


class StateManager(): 
    '''
    state manager
    '''

    def __init__(self): 
        '''
        init
        '''
        # max history length
        self.MAX_LENGTH = 5

        default_state = State()

        # history state: [..., S t-2, S t-1]
        self.arr_state  = [default_state for x in range(self.MAX_LENGTH)]

        # hp threshold to take hulu.
        self.HULU_THRESHOLD = 60

        # possible state id, see self.generate_state_id()
        # 0 1 2 3 4 <----> class_id
        self.NORMAL_STATE_ID    = 0
        self.TUCI_STATE_ID      = 1
        self.QINNA_STATE_ID     = 2
        self.FUZHOU_STATE_ID    = 3
        self.BAD_TUCI_STATE_ID  = 4

        # extra states
        self.PLAYER_HP_DOWN_STATE_ID    = 5
        self.HULU_STATE_ID              = 6

        # more extra states
        self.ATTACK_AFTER_DAMAGE_STATE_ID   = 7

        # more extra states
        self.POSTURE_CRASH_STATE_ID     = 8

        # more extra states
        self.POSTURE_DOWN_STATE_ID      = 10

        # more extra states
        self.PARRY_AFTER_ATTACK_STATE_ID_1  = 11
        self.PARRY_AFTER_ATTACK_STATE_ID_2  = 12
        self.PARRY_AFTER_ATTACK_STATE_ID_3  = 13
        self.PARRY_AFTER_ATTACK_STATE_ID_4  = 14
        self.PARRY_AFTER_ATTACK_STATE_ID_5  = 15
        self.PARRY_AFTER_ATTACK_STATE_ID_6  = 16
        self.PARRY_AFTER_ATTACK_STATE_ID_7  = 17
        self.PARRY_AFTER_ATTACK_STATE_ID_8  = 18
        self.PARRY_AFTER_ATTACK_STATE_ID_9  = 19

        self.arr_parry_after_attack_state_id = [
            self.PARRY_AFTER_ATTACK_STATE_ID_1,
            self.PARRY_AFTER_ATTACK_STATE_ID_2,
            self.PARRY_AFTER_ATTACK_STATE_ID_3,
            self.PARRY_AFTER_ATTACK_STATE_ID_4,
            self.PARRY_AFTER_ATTACK_STATE_ID_5,
            self.PARRY_AFTER_ATTACK_STATE_ID_6,
            self.PARRY_AFTER_ATTACK_STATE_ID_7,
            self.PARRY_AFTER_ATTACK_STATE_ID_8,
            self.PARRY_AFTER_ATTACK_STATE_ID_9,
        ]

        self.rule = Rule()

        # images similarity
        self.orb    = cv2.ORB_create()
        self.bf     = cv2.BFMatcher(cv2.NORM_HAMMING, crossCheck=True)


    def save(self, state): 
        '''
        add a new state to the state history
        '''
        log.debug('add a new state to the state history')
        if len(self.arr_state) >= self.MAX_LENGTH: 
            # remove the first one (oldest one)
            self.arr_state.pop(0)

        # populate arr_history_class_id
        state.arr_history_class_id = self.get_all_history_class_id()

        # generate state id, might be changed later.
        state.state_id = self.generate_state_id(state)

        # the last opportunity to generate extra state id
        value = self.generate_extra_state_id(state)
        if value is not None: 
            state.state_id = value
            log.debug('generate_extra_state_id, state_id: %s(history num: %s)' % (state.state_id, 
                state.num_parry_steps_after_attack))

        # the final state id
        state.final_state_id = state.state_id

        # generate action space key
        state.action_space_key = self.rule.generate_action_space_key(state, self)

        # save it, at last.
        self.arr_state.append(state)


    def get_all_history_class_id(self): 
        '''
        get all the states' class id
        '''
        return [state.class_id for state in self.arr_state]


    def generate_state_id(self, state): 
        '''
        generate state id 
        '''
        last_state = self.get_last_state()

        # if player posture crash, this is a extra state
        if state.is_player_posture_crash: 
            state_id = self.POSTURE_CRASH_STATE_ID
            log.debug('extra state player_posture_crash %s' % (state_id))
            return state_id

        # if player hp is down, this is a extra state
        if state.is_player_hp_down: 
            state_id = self.PLAYER_HP_DOWN_STATE_ID
            log.debug('extra state player_hp_down %s' % (state_id))
            return state_id

        # check if boss is stunned, and player hp less than threshold, this is a extra state to take hulu.
        if state.is_boss_hp_down and state.player_hp < self.HULU_THRESHOLD: 
            state_id = self.HULU_STATE_ID
            log.debug('extra state take_hulu %s' % (state_id))
            return state_id

        # if player hurt the boss, this is a extra state to attack
        if last_state.state_id in [
                self.TUCI_STATE_ID,
                self.QINNA_STATE_ID,
                self.FUZHOU_STATE_ID,
                ]: 
            if state.is_boss_hp_down: 
                state_id = self.ATTACK_AFTER_DAMAGE_STATE_ID
                log.debug('extra state attack_after_damage %s' % (state_id))
                return state_id

        # player's attack angered the boss, he will do TUCI maybe.
        '''
        if self.arr_state[-1].state_id in [self.ATTACK_AFTER_DAMAGE_STATE_ID,
                ] and self.arr_state[-2].state_id in [
                    self.QINNA_STATE_ID,
                ]:
            class_id = state.class_id
            if class_id == state.BAD_TUCI_CLASS_ID: 
                number_of_history_needed = 0
                signal_strength = 0
                for i in range(0, number_of_history_needed): 
                    if state.arr_history_class_id[-1 * (i + 1)] == class_id: 
                        signal_strength += 1

                log.debug('class_id: %s, signal_strength: %s, number_of_history_needed: %s' % (class_id, signal_strength, number_of_history_needed))
                if signal_strength >= number_of_history_needed: 
                    state_id = self.TUCI_STATE_ID
                    log.debug('extra state tuci after attack after attack: %s' % (state_id))
                    return state_id
        '''

        # if posture down to a reasonable value
        if state.is_player_posture_down_ok: 
            if state.class_id in [state.NORMAL_CLASS_ID]: 
                sim = self.image_similarity(last_state.image, state.image)
                log.debug('extra state posture down, check sim[%.5f]' % (sim))

                if sim > 0.9612 and sim < 0.99: 
                    state_id = self.POSTURE_DOWN_STATE_ID
                    return state_id

        # default case, use the class id derived from the classification model.
        # some classes need to check signal strength
        # only when the signal strength is good enough, will do attack.
        class_id = state.class_id
        # class 0, 4
        if class_id == state.NORMAL_CLASS_ID: 
            state_id = class_id
            log.debug('class_id is NORMAL_CLASS_ID, class_id[%s]->state_id[%s]' % (class_id, state_id))
            return state_id

        if class_id == state.BAD_TUCI_CLASS_ID: 
            state_id = class_id
            log.debug('class_id is BAD_TUCI_CLASS_ID, class_id[%s]->state_id[%s]' % (class_id, state_id))
            return state_id

        # class 1, 2, 3
        number_of_history_needed = 2
        if class_id == state.FUZHOU_CLASS_ID: 
            number_of_history_needed = 2

        signal_strength = 0
        for i in range(0, number_of_history_needed): 
            if state.arr_history_class_id[-1 * (i + 1)] == class_id: 
                signal_strength += 1

        log.debug('class_id: %s, signal_strength: %s, number_of_history_needed: %s' % (class_id, signal_strength, number_of_history_needed))
        if signal_strength >= number_of_history_needed: 
            state_id = class_id
            log.debug('signal_strength big enough, state_id[%s]' % (state_id))
            # should clear the history?
            return state_id

        # default case, default state
        state_id = self.NORMAL_STATE_ID
        log.debug('signal_strength NOT big enough, fall back to default state_id[%s]' % (state_id))
        return state_id


    def generate_extra_state_id(self, state): 
        '''
        if this state is a parry state and after attack
        '''
        # check the state is a parry state after attack
        if self.rule.is_parry_after_attack_state(state, self): 
            state.is_parry_after_attack = True
            last_state = self.get_last_state()
            state.num_parry_steps_after_attack = last_state.num_parry_steps_after_attack + 1

        if state.num_parry_steps_after_attack == 0: 
            return None

        # [10, 20 ..., 80]
        arr_threshold = [i * 10 for i in range(1, 9)]

        for i in range(0, len(arr_threshold)): 
            if state.num_parry_steps_after_attack <= arr_threshold[i]: 
                return self.arr_parry_after_attack_state_id[i]

        return self.arr_parry_after_attack_state_id[-1]


    def get_last_state(self): 
        '''
        get the last state from history array
        '''
        return self.arr_state[-1]


    def image_similarity(self, img_1, img_2): 
        '''
        calculate images similarity
        '''
        if img_1 is None: 
            sim = 0
            return 0

        img_1 = img_1[100:, 50:-50]
        img_2 = img_2[100:, 50:-50]

        gray_1 = cv2.cvtColor(img_1, cv2.COLOR_BGR2GRAY)
        gray_2 = cv2.cvtColor(img_2, cv2.COLOR_BGR2GRAY)

        kp_1, des_1 = self.orb.detectAndCompute(gray_1, None)
        kp_2, des_2 = self.orb.detectAndCompute(gray_2, None)

        if des_1 is None or des_2 is None: 
            sim = 0
            return sim

        matches = self.bf.match(des_1, des_2)
        similar_regions = [i for i in matches if i.distance < 70]
        sim = len(similar_regions) / len(matches)
        return sim



